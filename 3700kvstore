#!/usr/bin/env python3

import argparse, socket, time, json, select, struct, sys, math, os, random
from datetime import datetime

BROADCAST = "FFFF"
HEARTBEAT_TIMEOUT = 150

class Replica:
    def __init__(self, port, id, others):
        self.port = port
        self.id = id
        self.others = others
        self.leader = 'FFFF'
        self.term = 0
        self.voted_for = None
        self.votes_recieved = set() # unrepeated unordered votes this replica has received
        self.election_timer = datetime.now() # start election timer
        self.timeout = random.randint(410, 600) # randomize the replica's election timeout
        self.last_heartbeat_sent = {} # track last heartbeast sent per server
        self.status = "Follower"
        self.log = [{'term': -1}] # initialize log with empty msg of term -1
        self.state_machine = {} # key-value storage updated by put and accessed by get
        self.commit_index = 0
        self.last_applied = 0
        self.next_index = {} # for leader to track the next index to send to each replica
        self.match_index = {} # for leader to track the sync commit index for each replica
        self.count = 0
        self.get_log = []

        self.socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.socket.bind(('localhost', 0))

        #print("Replica %s starting up" % self.id, flush=True)
        hello = { "src": self.id, "dst": BROADCAST, "leader": self.leader, "type": "hello" }
        self.send(hello)
        #print("Sent hello message: %s" % hello, flush=True)

    def start_election(self):
        """
        Start the election for leader.
        """
        self.term += 1
        self.status = "Candidate"
        #self.leader = "FFFF"
        # self votes for self
        self.voted_for = self.id
        # self's received votes include self's vote
        self.votes_recieved.add(self.id)
        # request vote remote procedure call msg
        request_vote_rpc = { "src": self.id, "dst": BROADCAST, "leader": self.leader, "type": "requestVote",
                             "term": self.term, "candidateId": self.id, "lastLogIndex": self.get_last_index(),
                             "lastLogTerm": self.log[-1]["term"] }
        self.send(request_vote_rpc)
        self.election_timer = datetime.now()

    def send(self, message):
        #print("Sending message '%s'" % (message,), flush=True)
        self.socket.sendto(json.dumps(message).encode('utf-8'), ('localhost', self.port))

    def get_generalized_message(self, msg):
        return {'src': self.id, 'dst': msg['src'], 'leader': self.leader, 'MID': msg['MID'] }

    # get corresponding fail message for a request
    def get_fail_message(self, msg):
        return {**self.get_generalized_message(msg), 'type': 'fail'}

    def get_redirect_message(self, msg):
        return {**self.get_generalized_message(msg), 'type': 'redirect'}

    def get_ok_message(self, msg):
        return {**self.get_generalized_message(msg), 'type': 'ok'}

    def get_last_index(self):
        return len(self.log) - 1

    def do_put(self, msg):
        self.state_machine[msg['key']] = msg['value']
        #self.status == "Leader"
        if self.leader == self.id:
            self.send(self.get_ok_message(msg))


    def respond_to_get(self):
        for entry in self.get_log:
            self.send(entry)
        self.get_log.clear()
        #return self.state_machine[key]

    # handle put request and return corresponding response for put request
    def handle_put_request(self, msg):
        # if self.status == "Candidate":
        #     self.send(self.get_fail_message(msg))
        # elif self.status == "Follower":
        #     self.send(self.get_redirect_message(msg))
        if self.status != "Leader":
            self.send(self.get_redirect_message(msg))
        # if self is the leader
        else:
            entry = {'msg': msg, 'term': self.term}
            self.log.append(entry)
            for rid in self.others:
                # last log index >= nextIndex for follower
                if self.get_last_index() >= self.next_index[rid]:
                    self.send_append_entries_rpc(rid, self.log[self.next_index[rid]:])

    # handle get request and return corresponding response for get request
    def handle_get_request(self, msg):
        # if self.status == "Candidate":
        #     self.send(self.get_fail_message(msg))
        # elif self.status == "Follower":
        #     self.send(self.get_redirect_message(msg))
        if self.status != "Leader":
            self.send(self.get_redirect_message(msg))
        else:
            entry = {**self.get_ok_message(msg), 'value': self.state_machine.get(msg['key'], "")}
            self.get_log.append(entry)
            self.count = 0
            for rid in self.others:
                self.send_append_entries_rpc(rid)
            #self.send({**self.get_ok_message(msg), 'value': self.state_machine[msg['key']]})

    
    def update_term_and_convert_to_follower(self, msg):
        self.term = msg["term"]
        self.voted_for = None
        self.status = "Follower"
        self.leader = msg["leader"]
        self.election_timer = datetime.now()

    def send_append_entries_rpc(self, dst, entries = []):
        """
        Sends the RPC to append the given entries.
        Args:
            entries - list 
        """
        prev_log_idx = self.get_last_index() - len(entries)
        prev_log_term = self.log[prev_log_idx]['term']

        append_entries_rpc = { "src": self.id, "dst": dst, "leader": self.leader, "type": "appendEntries",
                               "term": self.term, "entries": entries, "prevLogIndex": prev_log_idx, "prevLogTerm": prev_log_term,
                               "leaderCommit": self.commit_index }
        
        self.send(append_entries_rpc)
        self.last_heartbeat_sent[dst] = datetime.now()

    def handle_append_entries(self, msg):
        # update commit index to be either all of the messages on server or the leader's commit index

        if msg["term"] > self.term:
            self.update_term_and_convert_to_follower(msg)
        elif msg["term"] == self.term:
            self.status = "Follower"
            self.leader = msg["leader"]
            self.election_timer = datetime.now()

        append_entries_response = { "src": self.id, "dst": msg['src'], "leader": self.leader,
                                    "type": "appendEntriesResponse", "term": self.term }

        if msg["term"] < self.term or msg["prevLogIndex"] > self.get_last_index() or self.log[msg["prevLogIndex"]]["term"] != msg["prevLogTerm"]:
            append_entries_response["success"] = False
            self.send(append_entries_response)
            return
        
        # idx starts at the last synced log index
        idx = msg["prevLogIndex"]
        need_to_delete = False
        for entry in msg["entries"]:
            # idx increments with each entry
            idx += 1
            # entries need to be deleted if the terms don't match
            if idx < len(self.log) and self.log[idx]["term"] != entry["term"]:
                need_to_delete = True
                break
        
        # delete everything after the calculated index
        if need_to_delete:
            self.log = self.log[:idx]

        # append all unsynced entries
        for entry in msg["entries"]:
            if entry not in self.log:
                self.log.append(entry)

        # update commit index to be either all of the messages on server or the leader's commit index
        if msg["leaderCommit"] > self.commit_index:
            self.commit_index = min(msg["leaderCommit"], self.get_last_index())

        append_entries_response["lastLogIndex"] = self.get_last_index()
        append_entries_response["success"] = True
        self.send(append_entries_response)


    def handle_append_entries_response(self, msg):
        """
        
        """
        # if the msg term is more advanced than self's, fast forward self
        if msg['term'] > self.term:
            self.update_term_and_convert_to_follower(msg)
            #return

        # if append didn't succeed, exit 
        if not msg['success']:
            self.next_index[msg['src']] -= 1
            return
        
        self.count += 1
        if self.count + 1 > (len(self.others) / 2):
            self.respond_to_get()

        self.match_index[msg['src']] = msg["lastLogIndex"]
        self.next_index[msg['src']] = self.match_index[msg['src']] + 1

        for rid in self.others:
            n = self.match_index[rid]
            if n > self.commit_index and n < len(self.log) and self.log[n]["term"] == self.term:
                count = 1

                for last_idx in self.match_index.values():
                    if last_idx >= n:
                        count += 1
                # if more than half of the replicas match to this point, commit index is fast forwarded
                if count > (len(self.others) / 2):
                    self.commit_index = n

                    
        self.apply_if_needed()

        # for idx in range(self.commit_index + 1, len(self.log)):
        #     count = 0
        #     for last_idx in self.match_index.values():
        #         if last_idx >= idx:
        #             count += 1

        #     if count > (len(self.others) / 2):
        #         self.commit_index = idx


    def handle_vote_request(self, msg):
        if msg['term'] > self.term:
            self.update_term_and_convert_to_follower(msg)

        vote_response = {'src': self.id, 'dst': msg['candidateId'], 'leader': self.leader,
                         'type': 'voteResponse', 'term': self.term }

        log_up_to_date = msg["lastLogIndex"] > self.get_last_index() or (msg["lastLogIndex"] == self.get_last_index() and msg["lastLogTerm"] >= self.log[msg["lastLogIndex"]]["term"]) 

        # if the self term is current to the msg term/log and the msg voted for same candidate as self/self hasn't voted yet
        if msg['term'] == self.term and log_up_to_date and self.voted_for in [msg['candidateId'], None]:
            # self votes for candidate in msg
            self.voted_for = msg['candidateId']
            vote_response['voteGranted'] = True
        else:
            # if self voted for someone else TODO
            vote_response['voteGranted'] = False

        self.election_timer = datetime.now()
        self.send(vote_response)


    def handle_vote_response(self, msg):
        # if msg term is more advanced than self's term, update the self to flash forward to new term
        if msg['term'] > self.term:
            self.update_term_and_convert_to_follower(msg)

        # if msg term is current with self term and self is candidate and msg voted for this candidate
        elif self.status == "Candidate" and msg['term'] == self.term and msg['voteGranted']:
            # add sender to voters for this candidate
            self.votes_recieved.add(msg['src'])
            # if more than half of the servers voted for self, self is leader
            if len(self.votes_recieved) >= ((len(self.others) + 1) / 2) + 1:
                self.status = "Leader"
                self.leader = self.id
                self.election_timer = datetime.now()
                #print("yay im leader", flush=True)
                for rid in self.others:
                    self.next_index[rid] = len(self.log)
                    self.match_index[rid] = 0
                    self.send_append_entries_rpc(rid)



    # delegate request to corresponding function
    def handle_request(self, msg):
        if msg['type'] == 'put':
            self.handle_put_request(msg)
        elif msg['type'] == 'get':
            self.handle_get_request(msg)
        elif msg['type'] == 'requestVote':
            self.handle_vote_request(msg)
        elif msg['type'] == 'voteResponse':
            self.handle_vote_response(msg)
        elif msg['type'] == 'appendEntries':
            self.handle_append_entries(msg)
        elif msg['type'] == 'appendEntriesResponse':
            self.handle_append_entries_response(msg)


    def election_timeout_elapsed(self):
        """
        Is the election age older than the timeout?
        Returns:
            timeout - boolean
        """
        return ((datetime.now() - self.election_timer).total_seconds() * 1000) >= self.timeout

    def heartbeat_timeout_elapsed(self, rid):
        """
        Has the time of the last heartbeat sent aged beyond the timeout?
        Returns:
            timeout - boolean
        """
        return (datetime.now() - self.last_heartbeat_sent[rid]).total_seconds() * 1000 >= HEARTBEAT_TIMEOUT

    def apply_if_needed(self):
        # recursively call until the last aplied is up to date with committed
        if self.commit_index > self.last_applied:
            self.last_applied += 1
            self.do_put(self.log[self.last_applied]["msg"])
            self.apply_if_needed()

    def run(self):
        """
        Entrypoint to K-V Store
        """
        while True:
            socks = select.select([self.socket], [], [], .15)[0]

            self.apply_if_needed()
            # if self.leader == self.id and self.status != "Leader":
            #     print("wtf", flush=True)
            #     print(self.status, flush=True)

            if self.status == "Leader":
                for rid in self.others:
                    if self.heartbeat_timeout_elapsed(rid):
                        self.send_append_entries_rpc(rid)

            elif self.election_timeout_elapsed():
                self.start_election()


            for conn in socks:
                data, addr = conn.recvfrom(65535)
                msg = json.loads(data.decode('utf-8'))
                #print("Received message '%s'" % (msg,), flush=True)

                self.handle_request(msg)





if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='run a key-value store')
    parser.add_argument('port', type=int, help="Port number to communicate")
    parser.add_argument('id', type=str, help="ID of this replica")
    parser.add_argument('others', metavar='others', type=str, nargs='+', help="IDs of other replicas")
    args = parser.parse_args()
    replica = Replica(args.port, args.id, args.others)
    replica.run()
