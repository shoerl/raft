#!/usr/bin/env python3

import argparse, socket, time, json, select, struct, sys, math, os, random
from datetime import datetime

BROADCAST = "FFFF"
HEARTBEAT_TIMEOUT = 300

class Replica:
    def __init__(self, port, id, others):
        self.port = port
        self.id = id
        self.others = others
        self.leader = 'FFFF'
        self.term = 0
        self.voted_for = None
        self.votes_recieved = set()
        self.election_timer = datetime.now()
        self.timeout = random.randint(400, 700)
        self.last_heartbeat_sent = {}
        self.status = "Follower"
        self.log = [{'term': -1}]
        self.state_machine = {}
        self.commit_index = 0
        self.last_applied = 0
        self.next_index = {}
        self.match_index = {}

        self.socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.socket.bind(('localhost', 0))

        print("Replica %s starting up" % self.id, flush=True)
        hello = { "src": self.id, "dst": BROADCAST, "leader": self.leader, "type": "hello" }
        self.send(hello)
        print("Sent hello message: %s" % hello, flush=True)

    def start_election(self):
        self.term += 1
        self.status = "Candidate"
        self.voted_for = self.id
        self.votes_recieved.add(self.id)
        request_vote_rpc = { "src": self.id, "dst": BROADCAST, "leader": self.leader, "type": "requestVote",
                             "term": self.term, "candidateId": self.id, "lastLogIndex": len(self.log) - 1,
                             "lastLogTerm": self.log[-1]["term"] }
        self.send(request_vote_rpc)
        self.election_timer = datetime.now()

    def send(self, message):
        print("Sending message '%s'" % (message,), flush=True)
        self.socket.sendto(json.dumps(message).encode('utf-8'), ('localhost', self.port))

    def get_generalized_message(self, msg):
        return {'src': self.id, 'dst': msg['src'], 'leader': self.leader, 'MID': msg['MID'] }

    # get corresponding fail message for a request
    def get_fail_message(self, msg):
        return {**self.get_generalized_message(msg), 'type': 'fail'}

    def get_redirect_message(self, msg):
        return {**self.get_generalized_message(msg), 'type': 'redirect'}

    def get_ok_message(self, msg):
        return {**self.get_generalized_message(msg), 'type': 'ok'}

    def do_put(self, msg):
        self.state_machine[msg['key']] = msg['value']
        if msg['dst'] == self.id:
            self.send(self.get_ok_message(msg))


    def do_get(self, key):
        return self.state_machine[key]

    # handle put request and return corresponding response for put request
    def handle_put_request(self, msg):
        if self.leader != self.id:
            self.send(self.get_redirect_message(msg))
        else:
            entry = {'msg': msg, 'term': self.term}
            self.log.append(entry)
            for rid in self.others:
                # last log index >= nextIndex for follower
                if (len(self.log) - 1) >= self.next_index[rid]:
                    self.send_append_entries_rpc(rid, self.log[self.next_index[rid]:])
            #self.send_append_entries_rpc([entry])
            #self.state_dict[msg['key']] = msg['value']
            #self.send_append_entries_rpc([entry])
            #return self.get_ok_message(msg)

    # handle get request and return corresponding response for get request
    def handle_get_request_and_obtain_response(self, msg):
        if self.leader != self.id:
            return self.get_redirect_message(msg)
        else:
            #entry = {'type': msg['type'], 'key': msg['key'], 'term': self.term}
            #self.log.append(entry)
            return {**self.get_ok_message(msg), 'value': self.state_machine[msg['key']]}

    def update_term_and_convert_to_follower(self, msg):
        self.term = msg["term"]
        self.voted_for = None
        self.status = "Follower"
        self.leader = msg["leader"]
        self.election_timer = datetime.now()

    def send_append_entries_rpc(self, dst, entries = []):
        prev_log_idx = len(self.log) - 1 - len(entries)
        prev_log_term = self.log[prev_log_idx]['term']

        append_entries_rpc = { "src": self.id, "dst": dst, "leader": self.leader, "type": "appendEntries",
                               "term": self.term, "entries": entries, "prevLogIndex": prev_log_idx, "prevLogTerm": prev_log_term,
                               "leaderCommit": self.commit_index }
        
        self.send(append_entries_rpc)
        self.last_heartbeat_sent[dst] = datetime.now()

    def handle_append_entries_and_obtain_response(self, msg):
        if msg["term"] > self.term:
            self.update_term_and_convert_to_follower(msg)
        
        if msg["term"] == self.term:
            self.status = "Follower"
            self.leader = msg["leader"]
            self.election_timer = datetime.now()

        append_entries_response = { "src": self.id, "dst": msg['src'], "leader": self.leader,
                                    "type": "appendEntriesResponse", "term": self.term }

        if msg["term"] < self.term or msg["prevLogIndex"] >= len(self.log) or self.log[msg["prevLogIndex"]]["term"] != msg["prevLogTerm"]:
            append_entries_response["success"] = False
            return append_entries_response
        
        idx = msg["prevLogIndex"]
        need_to_delete = False
        for entry in msg["entries"]:
            idx += 1
            if idx < len(self.log) and self.log[idx]["term"] != entry["term"]:
                need_to_delete = True
                break
        
        if need_to_delete:
            self.log = self.log[:idx]

        for entry in msg["entries"]:
            if entry not in self.log:
                self.log.append(entry)

        if msg["leaderCommit"] > self.commit_index:
            self.commit_index = min(msg["leaderCommit"], len(self.log) - 1)

        append_entries_response["lastLogIndex"] = len(self.log) - 1
        append_entries_response["success"] = True
        return append_entries_response


    def handle_append_entries_response(self, msg):
        if msg['term'] > self.term:
            self.update_term_and_convert_to_follower(msg)

        if not msg['success']:
            self.next_index[msg['src']] -= 1
            return
        
        self.match_index[msg['src']] = msg["lastLogIndex"]
        self.next_index[msg['src']] = self.match_index[msg['src']] + 1
        for idx in range(self.commit_index + 1, len(self.log)):
            count = 0
            for last_idx in self.match_index.values():
                if last_idx >= idx:
                    count += 1

            if count > (len(self.others) / 2):
                self.commit_index = idx


    def handle_vote_request_and_obtain_response(self, msg):
        if msg['term'] > self.term:
            self.update_term_and_convert_to_follower(msg)

        vote_response = {'src': self.id, 'dst': msg['candidateId'], 'leader': self.leader,
                         'type': 'voteResponse', 'term': self.term }

        log_up_to_date = msg["lastLogIndex"] >= len(self.log) - 1 and msg["lastLogTerm"] >= self.log[-1]["term"] 

        if msg['term'] == self.term and log_up_to_date and self.voted_for in [msg['candidateId'], None]:
            self.voted_for = msg['candidateId']
            vote_response['voteGranted'] = True
        else:
            vote_response['voteGranted'] = False

        self.election_timer = datetime.now()
        return vote_response


    def handle_vote_response(self, msg):
        if msg['term'] > self.term:
            self.update_term_and_convert_to_follower(msg)

        elif self.status == "Candidate" and msg['term'] == self.term and msg['voteGranted']:
            self.votes_recieved.add(msg['src'])

            if len(self.votes_recieved) > ((1 + len(self.others)) / 2):
                self.status = "Leader"
                self.leader = self.id
                self.election_timer = datetime.now()
                for rid in self.others:
                    self.next_index[rid] = len(self.log)
                    self.match_index[rid] = 0
                    self.send_append_entries_rpc(rid)
                print("im leader woo", flush=True)




    # delegate request to corresponding function
    def handle_request(self, msg):
        if msg['type'] == 'put':
            self.handle_put_request(msg)
        elif msg['type'] == 'get':
            resp = self.handle_get_request_and_obtain_response(msg)
            self.send(resp)
        elif msg['type'] == 'requestVote':
            resp = self.handle_vote_request_and_obtain_response(msg)
            self.send(resp)
        elif msg['type'] == 'voteResponse':
            self.handle_vote_response(msg)
        elif msg['type'] == 'appendEntries':
            resp = self.handle_append_entries_and_obtain_response(msg)
            self.send(resp)
        elif msg['type'] == 'appendEntriesResponse':
            self.handle_append_entries_response(msg)

        
    def election_timeout(self):
        return ((datetime.now() - self.election_timer).total_seconds() * 1000) >= self.timeout

    def ms_since_last_heartbeat(self, rid):
        return (datetime.now() - self.last_heartbeat_sent[rid]).total_seconds() * 1000

    def do_put_recur(self):
        if self.commit_index > self.last_applied:
            self.last_applied += 1
            self.do_put(self.log[self.last_applied]["msg"])
            self.do_put_recur()

    def run(self):
        while True:
            socks = select.select([self.socket], [], [], .15)[0]

            self.do_put_recur()

            if self.status == "Leader":
                for rid in self.others:
                    if self.ms_since_last_heartbeat(rid) > HEARTBEAT_TIMEOUT:
                            self.send_append_entries_rpc(rid)
            elif self.election_timeout():
                self.start_election()


            for conn in socks:
                data, addr = conn.recvfrom(65535)
                msg = json.loads(data.decode('utf-8'))
                print("Received message '%s'" % (msg,), flush=True)

                self.handle_request(msg)





if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='run a key-value store')
    parser.add_argument('port', type=int, help="Port number to communicate")
    parser.add_argument('id', type=str, help="ID of this replica")
    parser.add_argument('others', metavar='others', type=str, nargs='+', help="IDs of other replicas")
    args = parser.parse_args()
    replica = Replica(args.port, args.id, args.others)
    replica.run()
