#!/usr/bin/env python3

import argparse, socket, time, json, select, struct, sys, math, os, random
from datetime import datetime

BROADCAST = "FFFF"

class Replica:
    def __init__(self, port, id, others):
        self.port = port
        self.id = id
        self.others = others
        self.leader = 'FFFF'
        self.term = 0
        self.voted_for = None
        #TODO: make this a set
        self.votes_recieved = []
        self.election_timer = datetime.now()
        self.timeout = random.randint(400, 700)
        self.last_heartbeat_sent = datetime.now()
        self.status = "Follower"
        self.log = [{'term': -1}]
        self.state_machine = {}
        self.commit_index = 0
        self.last_applied = 0
        self.next_index = {}
        self.match_index = {}

        self.socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.socket.bind(('localhost', 0))

        print("Replica %s starting up" % self.id, flush=True)
        hello = { "src": self.id, "dst": BROADCAST, "leader": self.leader, "type": "hello" }
        self.send(hello)
        print("Sent hello message: %s" % hello, flush=True)

    def start_election(self):
        """
        Start the election for leader.
        """
        self.term += 1
        self.status = "Candidate"
        # self votes for self
        self.voted_for = self.id
        # self's received votes include self's vote
        self.votes_recieved = [self.id]
        # request vote remote procedure call msg
        request_vote_rpc = { "src": self.id, "dst": BROADCAST, "leader": self.leader, "type": "requestVote",
                             "term": self.term, "candidateId": self.id }
        self.send(request_vote_rpc)
        self.election_timer = datetime.now()

    def send(self, message):
        print("Sending message '%s'" % (message,), flush=True)
        self.socket.sendto(json.dumps(message).encode('utf-8'), ('localhost', self.port))

    def get_generalized_message(self, msg):
        return {'src': self.id, 'dst': msg['src'], 'leader': self.leader, 'MID': msg['MID'] }

    # get corresponding fail message for a request
    def get_fail_message(self, msg):
        return {**self.get_generalized_message(msg), 'type': 'fail'}

    def get_redirect_message(self, msg):
        return {**self.get_generalized_message(msg), 'type': 'redirect'}

    def get_ok_message(self, msg):
        return {**self.get_generalized_message(msg), 'type': 'ok'}

    def do_put(self, msg):
        self.state_machine[msg['key']] = msg['value']
        if msg['dst'] == self.id:
            self.send(self.get_ok_message(msg))


    def do_get(self, key):
        return self.state_machine[key]

    # handle put request and return corresponding response for put request
    def handle_put_request(self, msg):
        if self.leader != self.id:
            self.send(self.get_redirect_message(msg))
        # if self is the leader
        else:
            entry = {'msg': msg, 'term': self.term}
            self.send_append_entries_rpc([entry])
            #self.state_dict[msg['key']] = msg['value']
            #self.send_append_entries_rpc([entry])
            #return self.get_ok_message(msg)

    # handle get request and return corresponding response for get request
    def handle_get_request_and_obtain_response(self, msg):
        if self.leader != self.id:
            return self.get_redirect_message(msg)
        else:
            #entry = {'type': msg['type'], 'key': msg['key'], 'term': self.term}
            #self.log.append(entry)
            return {**self.get_ok_message(msg), 'value': self.state_machine[msg['key']]}

    def send_append_entries_rpc(self, entries = []):
        """
        Sends the RPC to append the given entries.
        Args:
            entries - list 
        """
        prev_log_idx = len(self.log) - 1
        prev_log_term = self.log[prev_log_idx]['term']

        self.log = [*self.log, *entries]

        append_entries_rpc = { "src": self.id, "dst": BROADCAST, "leader": self.leader, "type": "appendEntries",
                               "term": self.term, "entries": entries, "prevLogIndex": prev_log_idx, "prevLogTerm": prev_log_term,
                               "leaderCommit": self.commit_index }
        self.send(append_entries_rpc)
        # update last heartbeat sent time
        self.last_heartbeat_sent = datetime.now()

    def handle_append_entries_and_obtain_response(self, msg):
        """
        Append entries from the given msg as applicable and have a success response. Otherwise do not append entries if required conditions
        not met, and have a fail response. 
        Returns:
            msg - dict append msg response
        """
        # start election timer
        self.election_timer = datetime.now()
        # if msg term is more advanced than self's term, fast forward self
        if msg["term"] > self.term:
            self.term = msg["term"]
            self.voted_for = None
        
        # if self's term is up to date, self is a follower following the msg leader
        if msg["term"] == self.term:
            self.status = "Follower"
            self.leader = msg["leader"]

        append_entries_response = { "src": self.id, "dst": msg['src'], "leader": self.leader, "type": "appendEntriesResponse", "term": self.term }

        # if msg and self's term/log info is otherwise mismatched, this was a failed append
        if msg["term"] < self.term or msg["prevLogIndex"] >= len(self.log) or self.log[msg["prevLogIndex"]]["term"] != msg["prevLogTerm"]:
            append_entries_response["success"] = False
            return append_entries_response
        
        # idx starts at the last synced log index
        idx = msg["prevLogIndex"]
        need_to_delete = False
        for entry in msg["entries"]:
            # idx increments with each entry
            idx += 1
            # entries need to be deleted if the terms don't match
            if idx < len(self.log) and self.log[idx]["term"] != entry["term"]:
                need_to_delete = True
                break
        
        # delete everything after the calculated index
        if need_to_delete:
            self.log = self.log[:idx]

        # append all unsynced entries
        for entry in msg["entries"]:
            if entry not in self.log:
                self.log.append(entry)

        # update commit index to be either all of the messages on server or the leader's commit index
        if msg["leaderCommit"] > self.commit_index:
            self.commit_index = min(msg["leaderCommit"], len(self.log) - 1)

        append_entries_response["lastLogIndex"] = len(self.log) - 1
        append_entries_response["success"] = True
        return append_entries_response


    def handle_append_entries_response(self, msg):
        """
        
        """
        # if the msg term is more advanced than self's, fast forward self
        if msg['term'] > self.term:
            self.term = msg['term']
            self.status = "Follower"
            self.voted_for = None

        # if append didn't succeed, exit 
        if not msg['success']:
            return
        
        self.match_index[msg['src']] = msg['lastLogIndex']
        for idx in range(self.commit_index + 1, len(self.log)):
            count = 0
            for last_idx in self.match_index.values():
                if last_idx >= idx:
                    count += 1

            if count > (len(self.others) / 2):
                self.commit_index = idx

        if self.commit_index > self.last_applied:
            self.last_applied += 1
            # add msg to log
            self.do_put(self.log[self.last_applied]["msg"])

        return

    def handle_vote_request_and_obtain_response(self, msg):
        """
        """
        # if the msg term is more aged than the self's term, update the self to flash forward to the new term
        if msg['term'] > self.term:
            self.term = msg['term']
            self.status = "Follower"
            self.voted_for = None

        vote_response = {'src': self.id, 'dst': msg['candidateId'], 'leader': self.leader,
                         'type': 'voteResponse', 'term': self.term }

        # if the self term is current to the msg term and the msg voted for same candidate as self/self hasn't voted yet
        if msg['term'] == self.term and self.voted_for in [msg['candidateId'], None]:
            # self votes for the candidate in msg
            self.voted_for = msg['candidateId']
            vote_response['voteGranted'] = True
        else:
            # if self voted for someone else TODO
            vote_response['voteGranted'] = False

        return vote_response


    def handle_vote_response(self, msg):
        # if msg term is more advanced than self's term, update the self to flash forward to new term
        if msg['term'] > self.term:
            self.term = msg['term']
            self.status = "Follower"
            self.voted_for = None
            self.election_timer = datetime.now()

        # if msg term is current with self term and self is candidate and msg voted for this candidate
        elif self.status == "Candidate" and msg['term'] == self.term and msg['voteGranted']:
            # add sender to voters for this candidate
            self.votes_recieved.append(msg['src'])
            # if more than half of the servers voted for self, self is leader
            if len(self.votes_recieved) > ((1 + len(self.others)) / 2):
                self.status = "Leader"
                self.leader = self.id
                self.election_timer = datetime.now()
                print("im leader woo", flush=True)
                self.send_append_entries_rpc()



    # delegate request to corresponding function
    def handle_request(self, msg):
        if msg['type'] == 'put':
            self.handle_put_request(msg)
        elif msg['type'] == 'get':
            resp = self.handle_get_request_and_obtain_response(msg)
            self.send(resp)
        elif msg['type'] == 'requestVote':
            resp = self.handle_vote_request_and_obtain_response(msg)
            self.send(resp)
        elif msg['type'] == 'voteResponse':
            self.handle_vote_response(msg)
        elif msg['type'] == 'appendEntries':
            resp = self.handle_append_entries_and_obtain_response(msg)
            self.send(resp)
        elif msg['type'] == 'appendEntriesResponse':
            self.handle_append_entries_response(msg)

        
    def election_timeout(self):
        """
        Is the election age older than the timeout?
        Returns:
            timeout - boolean
        """
        return ((datetime.now() - self.election_timer).total_seconds() * 1000) >= self.timeout

    def ms_since_last_heartbeat(self):
        """
        Calculates the number of milliseconds since the last heartbeat sent.
        Returns:
            ms - number milliseconds
        """
        return (datetime.now() - self.last_heartbeat_sent).total_seconds() * 1000

    def run(self):
        """
        Entrypoint to K-V Store
        """
        while True:
            socks = select.select([self.socket], [], [], .15)[0]

            # if last applied message index isn't at the commit index, increment and 
            if self.commit_index > self.last_applied:
                self.last_applied += 1
                self.do_put(self.log[self.last_applied]["msg"])

            if self.status == "Leader" and self.ms_since_last_heartbeat() > 300:
                self.send_append_entries_rpc()
            # if this is not the leader and election has timed out, do election
            elif self.status != "Leader" and self.election_timeout():
                self.start_election()

            # handle all of the requests received
            for conn in socks:
                data, addr = conn.recvfrom(65535)
                msg = json.loads(data.decode('utf-8'))
                print("Received message '%s'" % (msg,), flush=True)

                self.handle_request(msg)





if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='run a key-value store')
    parser.add_argument('port', type=int, help="Port number to communicate")
    parser.add_argument('id', type=str, help="ID of this replica")
    parser.add_argument('others', metavar='others', type=str, nargs='+', help="IDs of other replicas")
    args = parser.parse_args()
    replica = Replica(args.port, args.id, args.others)
    replica.run()
