#!/usr/bin/env python3

import argparse, socket, time, json, select, struct, sys, math, os, random
from datetime import datetime

BROADCAST = "FFFF"

class Replica:
    def __init__(self, port, id, others):
        self.port = port
        self.id = id
        self.others = others
        self.leader = 'FFFF'
        self.term = 0
        self.voted_for = None
        #TODO: make this a set
        self.votes_recieved = []
        self.election_timer = datetime.now()
        self.timeout = random.randint(300, 700)
        self.last_heartbeat_sent = datetime.now()
        self.state = "Follower"

        self.socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.socket.bind(('localhost', 0))

        print("Replica %s starting up" % self.id, flush=True)
        hello = { "src": self.id, "dst": BROADCAST, "leader": self.leader, "type": "hello" }
        self.send(hello)
        print("Sent hello message: %s" % hello, flush=True)

    def start_election(self):
        self.term += 1
        self.state = "Candidate"
        self.voted_for = self.id
        self.votes_recieved = [self.id]
        request_vote_rpc = { "src": self.id, "dst": BROADCAST, "leader": self.leader, "type": "requestVote",
                             "term": self.term, "candidateId": self.id }
        self.send(request_vote_rpc)
        self.election_timer = datetime.now()

    def send(self, message):
        print("Sending message '%s'" % (message,), flush=True)
        self.socket.sendto(json.dumps(message).encode('utf-8'), ('localhost', self.port))

    def get_generalized_message(self, msg):
        return {'src': self.id, 'dst': msg['src'], 'leader': self.leader, 'MID': msg['MID'] }

    # get corresponding fail message for a request
    def get_fail_message(self, msg):
        return {**self.get_generalized_message(msg), 'type': 'fail'}

    def get_redirect_message(self, msg):
        return {**self.get_generalized_message(msg), 'type': 'redirect'}

    # handle put request and return corresponding response for put request
    def handle_put_request_and_obtain_response(self, msg):
        if self.leader != self.id:
            return self.get_redirect_message(msg)
        else:
            return self.get_fail_message(msg)

    # handle get request and return corresponding response for get request
    def handle_get_request_and_obtain_response(self, msg):
        if self.leader != self.id:
            return self.get_redirect_message(msg)
        else:
            return self.get_fail_message(msg)

    def send_append_entries_rpc(self):
        append_entries_rpc = { "src": self.id, "dst": BROADCAST, "leader": self.leader, "type": "appendEntries",
                               "term": self.term, "entries": [] }
        self.send(append_entries_rpc)
        self.last_heartbeat_sent = datetime.now()

    def handle_append_entries_and_obtain_response(self, msg):
        self.election_timer = datetime.now()
        if msg["term"] > self.term:
            self.term = msg["term"]
            self.voted_for = None

        if msg["term"] == self.term and msg["leader"] != self.leader:
            self.state = "Follower"
            self.leader = msg["leader"]
        


    def handle_vote_request_and_obtain_response(self, msg):
        if msg['term'] > self.term:
            self.term = msg['term']
            self.state = "Follower"
            self.voted_for = None

        vote_response = {'src': self.id, 'dst': msg['candidateId'], 'leader': self.leader,
                         'type': 'voteResponse', 'term': self.term }

        if msg['term'] == self.term and self.voted_for in [msg['candidateId'], None]:
            self.voted_for = msg['candidateId']
            vote_response['voteGranted'] = True
        else:
            vote_response['voteGranted'] = False

        return vote_response


    def handle_vote_response(self, msg):
        if msg['term'] > self.term:
            self.term = msg['term']
            self.state = "Follower"
            self.voted_for = None
            self.election_timer = datetime.now()

        elif self.state == "Candidate" and msg['term'] == self.term and msg['voteGranted']:
            self.votes_recieved.append(msg['src'])

            if len(self.votes_recieved) > ((1 + len(self.others)) / 2):
                self.state = "Leader"
                self.leader = self.id
                self.election_timer = datetime.now()
                print("im leader woo", flush=True)
                self.send_append_entries_rpc()



    # delegate request to corresponding function
    def handle_request(self, msg):
        if msg['type'] == 'put':
            resp = self.handle_put_request_and_obtain_response(msg)
            self.send(resp)
        elif msg['type'] == 'get':
            resp = self.handle_get_request_and_obtain_response(msg)
            self.send(resp)
        elif msg['type'] == 'requestVote':
            resp = self.handle_vote_request_and_obtain_response(msg)
            self.send(resp)
        elif msg['type'] == 'voteResponse':
            self.handle_vote_response(msg)
        elif msg['type'] == 'appendEntries':
            self.handle_append_entries_and_obtain_response(msg)
        
    def election_timeout(self):
        return ((datetime.now() - self.election_timer).total_seconds() * 1000) >= self.timeout

    def ms_since_last_heartbeat(self):
        return (datetime.now() - self.last_heartbeat_sent).total_seconds() * 1000

    def run(self):
        while True:
            socks = select.select([self.socket], [], [], .1)[0]
            if self.state == "Leader" and self.ms_since_last_heartbeat() > 100:
                self.send_append_entries_rpc()
            elif self.state != "Leader" and self.election_timeout():
                self.start_election()

            for conn in socks:
                data, addr = conn.recvfrom(65535)
                msg = json.loads(data.decode('utf-8'))
                print("Received message '%s'" % (msg,), flush=True)

                self.handle_request(msg)

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='run a key-value store')
    parser.add_argument('port', type=int, help="Port number to communicate")
    parser.add_argument('id', type=str, help="ID of this replica")
    parser.add_argument('others', metavar='others', type=str, nargs='+', help="IDs of other replicas")
    args = parser.parse_args()
    replica = Replica(args.port, args.id, args.others)
    replica.run()
